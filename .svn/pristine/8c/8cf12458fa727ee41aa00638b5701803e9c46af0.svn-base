<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="oracle.yp_zwc_rst">

<select id="select_reto_cost_count_cnt" resultType="double">
/* oracle.yp_zwc_rst.select_reto_cost_count_cnt */
SELECT 
	count(*) AS cnt
FROM TBL_WORKING_RETO_COST_COUNT A
LEFT OUTER JOIN TBL_WORKING_MASTER B
ON A.VENDOR_CODE = B.CODE
WHERE 1=1
AND CHECK_YYYY = #{CHECK_YYYY}
AND GUBUN_CODE = #{GUBUN_CODE}
</select>


<select id="select_reto_cost_count" resultType="HashMap">
/* oracle.yp_zwc_rst.select_reto_cost_count */
SELECT 
	A.CHECK_YYYY,
	A.VENDOR_CODE,
	B.CODE_NAME AS VENDOR_NAME,
	B.REPRESENTATIVE AS REPRESENTATIVE,
	A.GUBUN_CODE,
	A.AMOUNT1,
	A.AMOUNT2,
	SUB_TOTAL,
	VAT,
	TOTAL,
	CURRENTLY_SUBCONTRACTING_COST,
	LAST_YEAR_SUBCONTRACTING_COST,
	A.SAVE_MONEY_AMOUNT,
	RETROACT_AMOUNT,
	A.DIFF_AMOUNT,
	A.PRE_RETROACT_AMOUNT,
	SLIP_NUMBER,
    STATUS,
    F_GETCODENAME('YP_APPR_STATUS', STATUS) AS STATUS_TXT,
	B.SAP_CODE,
	A.BUDAT
FROM TBL_WORKING_RETO_COST_COUNT A
LEFT OUTER JOIN TBL_WORKING_MASTER B
ON A.VENDOR_CODE = B.CODE
WHERE 1=1
AND CHECK_YYYY = #{CHECK_YYYY}
AND GUBUN_CODE = #{GUBUN_CODE}
</select>

<update id="merge_tbl_working_monthly_report_retro">
/* oracle.yp_zwc_rst.merge_tbl_working_monthly_report_retro */
MERGE INTO TBL_WORKING_MONTHLY_RPT_RT A
USING (
	SELECT
		X.CHECK_YYYYMM,
		X.BASE_YYYY,
		X.VENDOR_CODE,
		X.CONTRACT_CODE,
		X.MANHOUR,
		X.UNIT_PRICE,
		X.MONTH_STANDARD_AMOUNT,
		X.QUANTITY,
		NULL AS QUANTITY_CHANGED,
		X.SUBCONTRACTING_COST,
		X.EXTENSION_HOUR,
		X.EXTENSION_AMOUNT,
		X.NIGHT_HOUR,
		X.NIGHT_AMOUNT,
		X.SATURDAY_MANHOUR,
		X.SATURDAY_AMOUNT,
		X.HOLIDAY_MANHOUR,
		X.HOLIDAY_AMOUNT,
		X.REWARD_RATE,
		X.REWARD_AMOUNT,
		X.REWARD_REASON,
		X.ADDITIONAL_AMOUNT,
		X.ADDITIONAL_BASIS,
		X.ADDITIONAL_REASON,
		X.PENALTY_AMOUNT,
		X.PENALTY_BASIS,
		X.PENALTY_REASON,
		NVL(X.SUBCONTRACTING_COST, 0) + 
		NVL(X.EXTENSION_AMOUNT, 0) + NVL(X.NIGHT_AMOUNT, 0) + NVL(X.SATURDAY_AMOUNT, 0) + NVL(X.HOLIDAY_AMOUNT, 0) + 
		NVL(X.REWARD_AMOUNT, 0) + NVL(X.ADDITIONAL_AMOUNT, 0) - 
		NVL(X.PENALTY_AMOUNT, 0) AS PAY_AMOUNT, /* 패널티는 빼기 */
		X.STATUS,
		#{s_emp_code} AS REG_EMP,
		SYSDATE AS REG_DATE,
		#{s_emp_code} AS UPD_EMP,
		SYSDATE AS UPD_DATE
	FROM (
		SELECT
			Z.CHECK_YYYYMM,
			A.BASE_YYYY,
			A.VENDOR_CODE,
			A.CONTRACT_CODE,
			A.RETROACT_START_DATE,
			A.RETROACT_END_DATE,
			NVL(C.COLLECTION_MANHOUR, 0) AS MANHOUR, -- 공수
			D.UNIT_PRICE AS UNIT_PRICE, -- 단가
			D.MONTH_STANDARD_AMOUNT AS MONTH_STANDARD_AMOUNT, -- 월기준량
			A.GUBUN_CODE AS GUBUN_CODE,
			CASE WHEN A.GUBUN_CODE = '2' THEN D.MONTH_STANDARD_AMOUNT ELSE C.WORKLOAD END AS QUANTITY, -- 물량
			D.UNIT_PRICE * CASE WHEN A.GUBUN_CODE = '2' THEN D.MONTH_STANDARD_AMOUNT ELSE C.WORKLOAD END AS SUBCONTRACTING_COST, -- 월도급비
			B.EXTENSION_HOUR AS EXTENSION_HOUR,
			B.EXTENSION_HOUR * D.OVERTIME_EXTENSION AS EXTENSION_AMOUNT,
			B.NIGHT_HOUR AS NIGHT_HOUR,
			B.NIGHT_HOUR * D.OVERTIME_NIGHT AS NIGHT_AMOUNT,
			B.SATURDAY_HOUR AS SATURDAY_MANHOUR,
			B.SATURDAY_HOUR * D.OVERTIME_SATURDAY AS SATURDAY_AMOUNT,
			B.HOLIDAY_HOUR AS HOLIDAY_MANHOUR,
			B.HOLIDAY_HOUR * D.OVERTIME_HOLIDAY AS HOLIDAY_AMOUNT,
			Z.REWARD_RATE,
			Z.REWARD_AMOUNT,
			Z.REWARD_REASON,
			Z.ADDITIONAL_AMOUNT,
			Z.ADDITIONAL_BASIS,
			Z.ADDITIONAL_REASON,
			Z.PENALTY_AMOUNT,
			Z.PENALTY_BASIS,
			Z.PENALTY_REASON,
			Z.STATUS
		FROM TBL_WORKING_SUBC A
		LEFT OUTER JOIN (
			SELECT
				B.BASE_YYYY, B.VENDOR_CODE, B.CONTRACT_CODE,
				SUM(B.EXTENSION_HOUR) AS EXTENSION_HOUR,
				SUM(B.NIGHT_HOUR) AS NIGHT_HOUR,
				SUM(B.SATURDAY_HOUR) AS SATURDAY_HOUR,
				SUM(B.HOLIDAY_HOUR) AS HOLIDAY_HOUR
			FROM TBL_WORKING_DAILY_REPORT B
			INNER JOIN TBL_WORKING_SUBC S /* 소급시작, 종료일 사이 구간 조회 */
				ON B.BASE_YYYY = S.BASE_YYYY
				AND B.VENDOR_CODE = S.VENDOR_CODE
				AND B.CONTRACT_CODE = S.CONTRACT_CODE
				AND B.BASE_YYYYMMDD BETWEEN S.RETROACT_START_DATE AND S.RETROACT_END_DATE /* 소급구간인 일보 조회 - 연장, 야간, 토요, 휴일 */
			WHERE 1=1
			AND B.BASE_YYYY = #{BASE_YYYY}
			GROUP BY B.BASE_YYYY, B.VENDOR_CODE, B.CONTRACT_CODE
		) B /* 일보 - 연장, 야간, 토요, 휴일 */
			ON A.BASE_YYYY = B.BASE_YYYY
			AND A.VENDOR_CODE = B.VENDOR_CODE
			AND A.CONTRACT_CODE = B.CONTRACT_CODE
		LEFT OUTER JOIN (
			SELECT
				C.BASE_YYYY, C.VENDOR_CODE, C.CONTRACT_CODE,
				SUM(C.MANHOUR) AS MANHOUR,
				SUM(C.COLLECTION_MANHOUR) AS COLLECTION_MANHOUR,
				SUM(C.WORKLOAD) AS WORKLOAD
			FROM (
				SELECT
					C.BASE_YYYY, C.VENDOR_CODE, C.CONTRACT_CODE,
					C.MANHOUR,
					CASE WHEN NVL(C.COLLECTION_MANHOUR, 0) = 0 THEN C.MANHOUR ELSE C.COLLECTION_MANHOUR END AS COLLECTION_MANHOUR,
					C.WORKLOAD AS WORKLOAD
				FROM TBL_WORKING_DAILY_REPORT_DT C
				INNER JOIN TBL_WORKING_SUBC S /* 소급시작, 종료일 사이 구간 조회 */
					ON C.BASE_YYYY = S.BASE_YYYY
					AND C.VENDOR_CODE = S.VENDOR_CODE
					AND C.CONTRACT_CODE = S.CONTRACT_CODE
					AND C.BASE_YYYYMMDD BETWEEN S.RETROACT_START_DATE AND S.RETROACT_END_DATE /* 소급구간인 일보 조회 - 공수, 물량 */
				WHERE 1=1
				AND C.BASE_YYYY = #{BASE_YYYY}
			) C
			GROUP BY C.BASE_YYYY, C.VENDOR_CODE, C.CONTRACT_CODE
		) C /* 일보 - 실공수, 물량 */
			ON A.BASE_YYYY = C.BASE_YYYY
			AND A.VENDOR_CODE = C.VENDOR_CODE
			AND A.CONTRACT_CODE = C.CONTRACT_CODE
		LEFT OUTER JOIN (
			SELECT
				D.BASE_YYYY,
				D.VENDOR_CODE,
				D.CONTRACT_CODE,
				D.UNIT_PRICE,
				D.MONTH_STANDARD_AMOUNT,
				D.OVERTIME_EXTENSION,
				D.OVERTIME_NIGHT,
				D.OVERTIME_SATURDAY,
				D.OVERTIME_HOLIDAY
			FROM TBL_WORKING_SUBC_CTN D -- 계약내용
			WHERE 1=1
		) D
			ON A.BASE_YYYY = D.BASE_YYYY
			AND A.VENDOR_CODE = D.VENDOR_CODE
			AND A.CONTRACT_CODE = D.CONTRACT_CODE
		INNER JOIN TBL_WORKING_MONTHLY_REPORT Z
			ON A.BASE_YYYY = Z.BASE_YYYY
			AND A.VENDOR_CODE = Z.VENDOR_CODE
			AND A.CONTRACT_CODE = Z.CONTRACT_CODE
		WHERE 1=1
		AND #{BASE_YYYY} BETWEEN SUBSTR(A.RETROACT_START_DATE, 1, 4) AND SUBSTR(A.RETROACT_END_DATE, 1, 4)
		AND Z.BASE_YYYY = #{BASE_YYYY}
	) X
	ORDER BY X.CHECK_YYYYMM, X.BASE_YYYY, X.VENDOR_CODE, X.CONTRACT_CODE
) B
ON (
		A.CHECK_YYYYMM = B.CHECK_YYYYMM
	AND A.BASE_YYYY = B.BASE_YYYY
	AND A.VENDOR_CODE = B.VENDOR_CODE
	AND A.CONTRACT_CODE = B.CONTRACT_CODE
)
WHEN NOT MATCHED THEN
INSERT (
	CHECK_YYYYMM,
	BASE_YYYY,
	VENDOR_CODE,
	CONTRACT_CODE,
	MANHOUR,
	UNIT_PRICE,
	MONTH_STANDARD_AMOUNT,
	QUANTITY,
	QUANTITY_CHANGED,
	SUBCONTRACTING_COST,
	EXTENSION_HOUR,
	EXTENSION_AMOUNT,
	NIGHT_HOUR,
	NIGHT_AMOUNT,
	SATURDAY_MANHOUR,
	SATURDAY_AMOUNT,
	HOLIDAY_MANHOUR,
	HOLIDAY_AMOUNT,
	REWARD_RATE,
	REWARD_AMOUNT,
	REWARD_REASON,
	ADDITIONAL_AMOUNT,
	ADDITIONAL_BASIS,
	ADDITIONAL_REASON,
	PENALTY_AMOUNT,
	PENALTY_BASIS,
	PENALTY_REASON,
	PAY_AMOUNT,
	STATUS,
	REG_EMP,
	REG_DATE
) VALUES (
	B.CHECK_YYYYMM,
	B.BASE_YYYY,
	B.VENDOR_CODE,
	B.CONTRACT_CODE,
	B.MANHOUR,
	B.UNIT_PRICE,
	B.MONTH_STANDARD_AMOUNT,
	B.QUANTITY,
	B.QUANTITY_CHANGED,
	B.SUBCONTRACTING_COST,
	B.EXTENSION_HOUR,
	B.EXTENSION_AMOUNT,
	B.NIGHT_HOUR,
	B.NIGHT_AMOUNT,
	B.SATURDAY_MANHOUR,
	B.SATURDAY_AMOUNT,
	B.HOLIDAY_MANHOUR,
	B.HOLIDAY_AMOUNT,
	B.REWARD_RATE,
	B.REWARD_AMOUNT,
	B.REWARD_REASON,
	B.ADDITIONAL_AMOUNT,
	B.ADDITIONAL_BASIS,
	B.ADDITIONAL_REASON,
	B.PENALTY_AMOUNT,
	B.PENALTY_BASIS,
	B.PENALTY_REASON,
	B.PAY_AMOUNT,
	B.STATUS,
	B.REG_EMP,
	B.REG_DATE
)
WHEN MATCHED THEN
UPDATE SET
	MANHOUR = B.MANHOUR,
	UNIT_PRICE = B.UNIT_PRICE,
	MONTH_STANDARD_AMOUNT = B.MONTH_STANDARD_AMOUNT,
	QUANTITY = B.QUANTITY,
	QUANTITY_CHANGED = B.QUANTITY_CHANGED,
	SUBCONTRACTING_COST = B.SUBCONTRACTING_COST,
	EXTENSION_HOUR = B.EXTENSION_HOUR,
	EXTENSION_AMOUNT = B.EXTENSION_AMOUNT,
	NIGHT_HOUR = B.NIGHT_HOUR,
	NIGHT_AMOUNT = B.NIGHT_AMOUNT,
	SATURDAY_MANHOUR = B.SATURDAY_MANHOUR,
	SATURDAY_AMOUNT = B.SATURDAY_AMOUNT,
	HOLIDAY_MANHOUR = B.HOLIDAY_MANHOUR,
	HOLIDAY_AMOUNT = B.HOLIDAY_AMOUNT,
	REWARD_RATE = B.REWARD_RATE,
	REWARD_AMOUNT = B.REWARD_AMOUNT,
	REWARD_REASON = B.REWARD_REASON,
	ADDITIONAL_AMOUNT = B.ADDITIONAL_AMOUNT,
	ADDITIONAL_BASIS = B.ADDITIONAL_BASIS,
	ADDITIONAL_REASON = B.ADDITIONAL_REASON,
	PENALTY_AMOUNT = B.PENALTY_AMOUNT,
	PENALTY_BASIS = B.PENALTY_BASIS,
	PENALTY_REASON = B.PENALTY_REASON,
	PAY_AMOUNT = B.PAY_AMOUNT,
	STATUS = B.STATUS,
	UPD_EMP = B.UPD_EMP,
	UPD_DATE = B.UPD_DATE
</update>

<update id="merge_tbl_working_reto_cost_count_storage_goods">
/* oracle.yp_zwc_rst.merge_tbl_working_reto_cost_count_storage_goods - 저장품 */
MERGE INTO TBL_WORKING_RETO_COST_COUNT A
USING (
	SELECT
		A.BASE_YYYY AS CHECK_YYYY,
		A.VENDOR_CODE AS VENDOR_CODE,
		'0' AS GUBUN_CODE,
		NULL AS AMOUNT1,
		NULL AS AMOUNT2,
		NVL(SUM(A.PAY_AMOUNT), 0) AS AMOUNT3,
		NVL(SUM(A.PAY_AMOUNT), 0) AS SUB_TOTAL,
		ROUND(NVL(SUM(A.PAY_AMOUNT), 0) * 0.1, 0) AS VAT,
		NVL(SUM(A.PAY_AMOUNT), 0) + ROUND(NVL(SUM(A.PAY_AMOUNT), 0) * 0.1, 0) AS TOTAL,
		NVL(SUM(A.PAY_AMOUNT), 0) + ROUND(NVL(SUM(A.PAY_AMOUNT), 0) * 0.1, 0) - 
		ROUND((NVL(SUM(A.PAY_AMOUNT), 0) + ROUND(NVL(SUM(A.PAY_AMOUNT), 0) * 0.1, 0)) * NVL(SUM(E.TARGET_MONTH), 0) / 100, 0) AS RETROACT_AMOUNT, -- 정산액
		ROUND((NVL(SUM(A.PAY_AMOUNT), 0) + ROUND(NVL(SUM(A.PAY_AMOUNT), 0) * 0.1, 0)) * NVL(SUM(E.TARGET_MONTH), 0) / 100, 0) AS SAVE_MONEY_AMOUNT, -- 분할입금액(적립금)
		NVL(SUM(A.PAY_AMOUNT), 0) + ROUND(NVL(SUM(A.PAY_AMOUNT), 0) * 0.1, 0) -
		ROUND((NVL(SUM(A.PAY_AMOUNT), 0) + ROUND(NVL(SUM(A.PAY_AMOUNT), 0) * 0.1, 0)) * NVL(SUM(E.TARGET_MONTH), 0) / 100, 0) -
		NVL(SUM(D.PRE_PAY_AMOUNT), 0) AS DIFF_AMOUNT, -- 차액
		NVL(SUM(D.PRE_PAY_AMOUNT), 0) AS PRE_RETROACT_AMOUNT, -- 기지급액 추가
		NVL(SUM(C.CURRENT_SUBCONTRACTING_COST), 0) AS CURRENTLY_SUBCONTRACTING_COST,
		NVL(SUM(C.ADJUST_SUBCONTRACTING_COST), 0) AS LAST_YEAR_SUBCONTRACTING_COST,
		NULL AS SLIP_NUMBER,
		NULL AS STATUS,
		#{s_emp_code} AS REG_EMP,
		SYSDATE AS REG_DATE,
		#{s_emp_code} AS UPD_EMP,
		SYSDATE AS UPD_DATE
	FROM TBL_WORKING_MONTHLY_RPT_RT A
	INNER JOIN TBL_WORKING_SUBC B
		ON A.BASE_YYYY = B.BASE_YYYY
		AND A.VENDOR_CODE = B.VENDOR_CODE
		AND A.CONTRACT_CODE = B.CONTRACT_CODE
		AND B.GUBUN_CODE = 3 -- 저장품
	LEFT OUTER JOIN TBL_WORKING_SUBC_COST_ADJUST C
		ON A.BASE_YYYY = B.BASE_YYYY
		AND A.VENDOR_CODE = B.VENDOR_CODE
	LEFT OUTER JOIN (
		SELECT
			S1.BASE_YYYY, S1.VENDOR_CODE,
			SUM(S1.PAY_AMOUNT) AS PRE_PAY_AMOUNT
		FROM TBL_WORKING_MONTHLY_REPORT S1
		INNER JOIN TBL_WORKING_SUBC S2
			ON S1.BASE_YYYY = S2.BASE_YYYY
			AND S1.VENDOR_CODE = S2.VENDOR_CODE
			AND S1.CONTRACT_CODE = S2.CONTRACT_CODE
			AND S1.CHECK_YYYYMM BETWEEN TO_CHAR(TO_DATE(S2.RETROACT_START_DATE, 'YYYYMMDD'), 'YYYYMM') AND TO_CHAR(TO_DATE(S2.RETROACT_END_DATE, 'YYYYMMDD'), 'YYYYMM')
		WHERE 1=1
		AND S1.BASE_YYYY = #{BASE_YYYY}
		GROUP BY S1.BASE_YYYY, S1.VENDOR_CODE
	) D
		ON A.BASE_YYYY = D.BASE_YYYY
		AND A.VENDOR_CODE = D.VENDOR_CODE
	LEFT OUTER JOIN (
		SELECT
			BASE_YYYY,
			VENDOR_CODE,
			CASE TO_CHAR(SYSDATE, 'MM')
				WHEN '01' THEN MONTH1
				WHEN '02' THEN MONTH2
				WHEN '03' THEN MONTH3
				WHEN '04' THEN MONTH4
				WHEN '05' THEN MONTH5
				WHEN '06' THEN MONTH6
				WHEN '07' THEN MONTH7
				WHEN '08' THEN MONTH8
				WHEN '09' THEN MONTH9
				WHEN '10' THEN MONTH10
				WHEN '11' THEN MONTH11
				WHEN '12' THEN MONTH12
			END AS TARGET_MONTH
		FROM TBL_WORKING_SAVE_MONEY_COST
		WHERE BASE_YYYY = #{BASE_YYYY}
	) E
		ON A.BASE_YYYY = E.BASE_YYYY
		AND A.VENDOR_CODE = E.VENDOR_CODE
	WHERE 1=1
	AND A.BASE_YYYY = #{BASE_YYYY}
	GROUP BY A.BASE_YYYY, A.VENDOR_CODE
) B
ON (
		A.CHECK_YYYY = B.CHECK_YYYY
	AND A.VENDOR_CODE = B.VENDOR_CODE
	AND A.GUBUN_CODE = B.GUBUN_CODE
)
WHEN NOT MATCHED THEN
INSERT (
	CHECK_YYYY,
	VENDOR_CODE,
	GUBUN_CODE,
	AMOUNT1, -- 협력업체_금액
	AMOUNT2, -- 물량관리_금액
	AMOUNT3, -- 저장품_금액
	SUB_TOTAL, -- 소계 [저장품: AMOUNT3, 그외: AMOUNT1+AMOUNT2]
	VAT, -- 부가세
	TOTAL, -- 합계
	RETROACT_AMOUNT, -- 정산액
	SAVE_MONEY_AMOUNT, -- 분할입금액(적립금)
	DIFF_AMOUNT, -- 차액
	PRE_RETROACT_AMOUNT, -- 기지급액
	CURRENTLY_SUBCONTRACTING_COST,
	LAST_YEAR_SUBCONTRACTING_COST,
	SLIP_NUMBER,
	STATUS,
	REG_EMP,
	REG_DATE
) VALUES (
	B.CHECK_YYYY,
	B.VENDOR_CODE,
	B.GUBUN_CODE,
	B.AMOUNT1,
	B.AMOUNT2,
	B.AMOUNT3,
	B.SUB_TOTAL,
	B.VAT,
	B.TOTAL,
	B.RETROACT_AMOUNT,
	B.SAVE_MONEY_AMOUNT,
	B.DIFF_AMOUNT,
	B.PRE_RETROACT_AMOUNT,
	B.CURRENTLY_SUBCONTRACTING_COST,
	B.LAST_YEAR_SUBCONTRACTING_COST,
	B.SLIP_NUMBER,
	B.STATUS,
	B.REG_EMP,
	B.REG_DATE
)
WHEN MATCHED THEN
UPDATE SET
	SUB_TOTAL = B.SUB_TOTAL,
	VAT = B.VAT,
	TOTAL = B.TOTAL,
	RETROACT_AMOUNT = B.RETROACT_AMOUNT,
	SAVE_MONEY_AMOUNT = B.SAVE_MONEY_AMOUNT,
	DIFF_AMOUNT = B.DIFF_AMOUNT,
	PRE_RETROACT_AMOUNT = B.PRE_RETROACT_AMOUNT,
	CURRENTLY_SUBCONTRACTING_COST = B.CURRENTLY_SUBCONTRACTING_COST,
	LAST_YEAR_SUBCONTRACTING_COST = B.LAST_YEAR_SUBCONTRACTING_COST,
	SLIP_NUMBER = B.SLIP_NUMBER,
	STATUS = B.STATUS,
	UPD_EMP = B.UPD_EMP,
	UPD_DATE = B.UPD_DATE
</update>

<update id="merge_tbl_working_reto_cost_count_else">
/* oracle.yp_zwc_rst.merge_tbl_working_reto_cost_count_else - 저장품 외 */
MERGE INTO TBL_WORKING_RETO_COST_COUNT A
USING (
	SELECT
		X.CHECK_YYYY,
		X.VENDOR_CODE,
		'1' AS GUBUN_CODE,
		NVL(SUM(X.AMOUNT1), 0) AS AMOUNT1,
		NVL(SUM(X.AMOUNT2), 0) AS AMOUNT2,
		NULL AS AMOUNT3,
		NVL(SUM(X.PAY_AMOUNT), 0) AS SUB_TOTAL,
		ROUND(NVL(SUM(X.PAY_AMOUNT), 0) * 0.1, 0) AS VAT,
		NVL(SUM(X.PAY_AMOUNT), 0) + ROUND(NVL(SUM(X.PAY_AMOUNT), 0) * 0.1, 0) AS TOTAL,
		NVL(SUM(X.PAY_AMOUNT), 0) + ROUND(NVL(SUM(X.PAY_AMOUNT), 0) * 0.1, 0) - 
		ROUND((NVL(SUM(X.PAY_AMOUNT), 0) + ROUND(NVL(SUM(X.PAY_AMOUNT), 0) * 0.1, 0)) * NVL(SUM(E.TARGET_MONTH), 0) / 100, 0) AS RETROACT_AMOUNT, -- 정산액
		ROUND((NVL(SUM(X.PAY_AMOUNT), 0) + ROUND(NVL(SUM(X.PAY_AMOUNT), 0) * 0.1, 0)) * NVL(SUM(E.TARGET_MONTH), 0) / 100, 0) AS SAVE_MONEY_AMOUNT, -- 분할입금액(적립금)
		NVL(SUM(X.PAY_AMOUNT), 0) + ROUND(NVL(SUM(X.PAY_AMOUNT), 0) * 0.1, 0) -
		ROUND((NVL(SUM(X.PAY_AMOUNT), 0) + ROUND(NVL(SUM(X.PAY_AMOUNT), 0) * 0.1, 0)) * NVL(SUM(E.TARGET_MONTH), 0) / 100, 0) -
		NVL(SUM(D.PRE_PAY_AMOUNT), 0) AS DIFF_AMOUNT, -- 차액
		NVL(SUM(D.PRE_PAY_AMOUNT), 0) AS PRE_RETROACT_AMOUNT, -- 기지급액 추가
		NVL(SUM(X.CURRENTLY_SUBCONTRACTING_COST), 0) AS CURRENTLY_SUBCONTRACTING_COST,
		NVL(SUM(X.LAST_YEAR_SUBCONTRACTING_COST), 0) AS LAST_YEAR_SUBCONTRACTING_COST,
		NULL AS SLIP_NUMBER,
		NULL AS STATUS,
		#{s_emp_code} AS REG_EMP,
		SYSDATE AS REG_DATE,
		#{s_emp_code} AS UPD_EMP,
		SYSDATE AS UPD_DATE
	FROM (
		SELECT
			A.BASE_YYYY AS CHECK_YYYY,
			A.VENDOR_CODE AS VENDOR_CODE,
			CASE WHEN B.GUBUN_CODE = '2' THEN NVL(A.PAY_AMOUNT, 0) ELSE 0 END AS AMOUNT1, -- 인력
			CASE WHEN B.GUBUN_CODE = '1' THEN NVL(A.PAY_AMOUNT, 0) ELSE 0 END AS AMOUNT2, -- 물량
			NVL(A.PAY_AMOUNT, 0) AS PAY_AMOUNT,
			NVL(C.CURRENT_SUBCONTRACTING_COST, 0) AS CURRENTLY_SUBCONTRACTING_COST,
			NVL(C.ADJUST_SUBCONTRACTING_COST, 0) AS LAST_YEAR_SUBCONTRACTING_COST
		FROM TBL_WORKING_MONTHLY_RPT_RT A
		INNER JOIN TBL_WORKING_SUBC B
			ON A.BASE_YYYY = B.BASE_YYYY
			AND A.VENDOR_CODE = B.VENDOR_CODE
			AND A.CONTRACT_CODE = B.CONTRACT_CODE
			AND B.GUBUN_CODE <![CDATA[<>]]> 3 -- 저장품 외
		LEFT OUTER JOIN TBL_WORKING_SUBC_COST_ADJUST C
			ON A.BASE_YYYY = B.BASE_YYYY
			AND A.VENDOR_CODE = B.VENDOR_CODE
		WHERE 1=1
		AND A.BASE_YYYY = #{BASE_YYYY}
	) X
	LEFT OUTER JOIN (
		SELECT
			S1.BASE_YYYY, S1.VENDOR_CODE,
			SUM(S1.PAY_AMOUNT) AS PRE_PAY_AMOUNT
		FROM TBL_WORKING_MONTHLY_REPORT S1
		INNER JOIN TBL_WORKING_SUBC S2
			ON S1.BASE_YYYY = S2.BASE_YYYY
			AND S1.VENDOR_CODE = S2.VENDOR_CODE
			AND S1.CONTRACT_CODE = S2.CONTRACT_CODE
			AND S1.CHECK_YYYYMM BETWEEN TO_CHAR(TO_DATE(S2.RETROACT_START_DATE, 'YYYYMMDD'), 'YYYYMM') AND TO_CHAR(TO_DATE(S2.RETROACT_END_DATE, 'YYYYMMDD'), 'YYYYMM')
		WHERE 1=1
		AND S1.BASE_YYYY = #{BASE_YYYY}
		GROUP BY S1.BASE_YYYY, S1.VENDOR_CODE
	) D
		ON X.CHECK_YYYY = D.BASE_YYYY
		AND X.VENDOR_CODE = D.VENDOR_CODE
	LEFT OUTER JOIN (
		SELECT
			BASE_YYYY,
			VENDOR_CODE,
			CASE TO_CHAR(SYSDATE, 'MM')
				WHEN '01' THEN MONTH1
				WHEN '02' THEN MONTH2
				WHEN '03' THEN MONTH3
				WHEN '04' THEN MONTH4
				WHEN '05' THEN MONTH5
				WHEN '06' THEN MONTH6
				WHEN '07' THEN MONTH7
				WHEN '08' THEN MONTH8
				WHEN '09' THEN MONTH9
				WHEN '10' THEN MONTH10
				WHEN '11' THEN MONTH11
				WHEN '12' THEN MONTH12
			END AS TARGET_MONTH
		FROM TBL_WORKING_SAVE_MONEY_COST
		WHERE BASE_YYYY = #{BASE_YYYY}
	) E
		ON X.CHECK_YYYY = E.BASE_YYYY
		AND X.VENDOR_CODE = E.VENDOR_CODE
	WHERE 1=1
	GROUP BY X.CHECK_YYYY, X.VENDOR_CODE
) B
ON (
		A.CHECK_YYYY = B.CHECK_YYYY
	AND A.VENDOR_CODE = B.VENDOR_CODE
	AND A.GUBUN_CODE = B.GUBUN_CODE
)
WHEN NOT MATCHED THEN
INSERT (
	CHECK_YYYY,
	VENDOR_CODE,
	GUBUN_CODE,
	AMOUNT1, -- 협력업체_금액
	AMOUNT2, -- 물량관리_금액
	AMOUNT3, -- 저장품_금액
	SUB_TOTAL, -- 소계 [저장품: AMOUNT3, 그외: AMOUNT1+AMOUNT2]
	VAT, -- 부가세
	TOTAL, -- 합계
	RETROACT_AMOUNT, -- 정산액
	SAVE_MONEY_AMOUNT, -- 분할입금액(적립금)
	DIFF_AMOUNT, -- 차액
	PRE_RETROACT_AMOUNT, -- 기지급액
	CURRENTLY_SUBCONTRACTING_COST,
	LAST_YEAR_SUBCONTRACTING_COST,
	SLIP_NUMBER,
	STATUS,
	REG_EMP,
	REG_DATE
) VALUES (
	B.CHECK_YYYY,
	B.VENDOR_CODE,
	B.GUBUN_CODE,
	B.AMOUNT1,
	B.AMOUNT2,
	B.AMOUNT3,
	B.SUB_TOTAL,
	B.VAT,
	B.TOTAL,
	B.RETROACT_AMOUNT,
	B.SAVE_MONEY_AMOUNT,
	B.DIFF_AMOUNT,
	B.PRE_RETROACT_AMOUNT,
	B.CURRENTLY_SUBCONTRACTING_COST,
	B.LAST_YEAR_SUBCONTRACTING_COST,
	B.SLIP_NUMBER,
	B.STATUS,
	B.REG_EMP,
	B.REG_DATE
)
WHEN MATCHED THEN
UPDATE SET
	SUB_TOTAL = B.SUB_TOTAL,
	VAT = B.VAT,
	TOTAL = B.TOTAL,
	RETROACT_AMOUNT = B.RETROACT_AMOUNT,
	SAVE_MONEY_AMOUNT = B.SAVE_MONEY_AMOUNT,
	DIFF_AMOUNT = B.DIFF_AMOUNT,
	PRE_RETROACT_AMOUNT = B.PRE_RETROACT_AMOUNT,
	CURRENTLY_SUBCONTRACTING_COST = B.CURRENTLY_SUBCONTRACTING_COST,
	LAST_YEAR_SUBCONTRACTING_COST = B.LAST_YEAR_SUBCONTRACTING_COST,
	SLIP_NUMBER = B.SLIP_NUMBER,
	STATUS = B.STATUS,
	UPD_EMP = B.UPD_EMP,
	UPD_DATE = B.UPD_DATE
</update>

<select id="select_zwc_rst_bill" resultType="HashMap">
/* oracle.yp_zwc_rst.select_zwc_rst_bill */
SELECT
	X.*,
	(SELECT S.CODE_NAME FROM TBL_WORKING_MASTER S WHERE SUBSTR(S.CODE, 1, 1) = 'V' AND S.CODE = X.VENDOR_CODE) AS VENDOR_NAME, -- 거래처
	(SELECT S.CODE_NAME FROM TBL_WORKING_MASTER S WHERE SUBSTR(S.CODE, 1, 1) = 'U' AND S.CODE = X.UNIT_CODE) AS UNIT_NAME -- 단위
FROM (
	SELECT
		A.BASE_YYYY AS BASE_YYYY, -- 년월
		A.VENDOR_CODE AS VENDOR_CODE, -- 거래처코드
		A.CONTRACT_CODE AS CONTRACT_CODE, -- 작업코드
		MAX(B.CONTRACT_NAME) AS CONTRACT_NAME, -- 작업명
		MAX(B.UNIT_CODE) AS UNIT_CODE, -- 단위코드
		NVL(SUM(A.QUANTITY), 0) AS QUANTITY, -- 작업량
		NVL(SUM(A.UNIT_PRICE), 0) AS UNIT_PRICE, -- 단가
		NVL(SUM(A.REWARD_AMOUNT), 0) AS REWARD_AMOUNT, -- 보상
		NVL(SUM(A.ADDITIONAL_AMOUNT), 0) AS ADDITIONAL_AMOUNT, -- 추가
		NVL(SUM(A.PENALTY_AMOUNT), 0) AS PENALTY_AMOUNT, -- 패널티
		NVL(SUM(A.HOLIDAY_AMOUNT), 0) AS HOLIDAY_AMOUNT, -- 휴일근무
		NVL(SUM(A.SATURDAY_AMOUNT), 0) AS SATURDAY_AMOUNT, -- 토요근무
		NVL(SUM(A.EXTENSION_AMOUNT), 0) AS EXTENSION_AMOUNT, -- 연장근무
		NVL(SUM(A.NIGHT_AMOUNT), 0) AS NIGHT_AMOUNT, -- 야간근무
		NVL(SUM(A.PAY_AMOUNT), 0) AS PAY_AMOUNT, -- 금액
		SUM(PRE_PAY_AMOUNT) AS PRE_PAY_AMOUNT, -- 기지급액,
		NVL(SUM(A.PAY_AMOUNT), 0) - SUM(PRE_PAY_AMOUNT) AS RETROACTIVE_AMOUNT -- 소급액
	FROM TBL_WORKING_MONTHLY_RPT_RT A
	INNER JOIN TBL_WORKING_SUBC B
		ON A.BASE_YYYY = B.BASE_YYYY
		AND A.VENDOR_CODE = B.VENDOR_CODE
		AND A.CONTRACT_CODE = B.CONTRACT_CODE
	INNER JOIN (
		SELECT
			C.BASE_YYYY,
			C.VENDOR_CODE,
			C.CONTRACT_CODE,
			NVL(SUM(C.PAY_AMOUNT), 0) AS PRE_PAY_AMOUNT
		FROM TBL_WORKING_MONTHLY_REPORT C
		INNER JOIN TBL_WORKING_SUBC S
			ON C.BASE_YYYY = S.BASE_YYYY
			AND C.VENDOR_CODE = S.VENDOR_CODE
			AND C.CONTRACT_CODE = S.CONTRACT_CODE
			AND C.CHECK_YYYYMM BETWEEN SUBSTR(S.RETROACT_START_DATE, 1, 6) AND SUBSTR(S.RETROACT_END_DATE, 1, 6)
		WHERE 1=1
		GROUP BY C.BASE_YYYY, C.VENDOR_CODE, C.CONTRACT_CODE
	) C -- 소급기간의 도급월보 소계를 구함
		ON A.BASE_YYYY = C.BASE_YYYY
		AND A.VENDOR_CODE = C.VENDOR_CODE
		AND A.CONTRACT_CODE = C.CONTRACT_CODE
	WHERE 1=1
	AND A.VENDOR_CODE = #{VENDOR_CODE}
	AND SUBSTR(A.CHECK_YYYYMM, 1, 4) = #{BASE_YYYY}
	GROUP BY A.BASE_YYYY, A.VENDOR_CODE, A.CONTRACT_CODE
) X
WHERE 1=1
</select>

<select id="zwc_rst_bill_representative" resultType="String">
/* oracle.yp_zwc_rst.zwc_rst_bill_representative */
SELECT
	NVL(A.REPRESENTATIVE, '　　　　　') AS REPRESENTATIVE
FROM TBL_WORKING_MASTER A
WHERE 1=1
AND A.CODE LIKE 'V%'
AND A.ENTERPRISE_GUBUN IN ('1', '2')
AND A.CODE = #{VENDOR_CODE}
</select>

<select id="select_zwc_rst_doc_create_dt_list" resultType="HashMap">
/* oracle.yp_zwc_rst.select_zwc_rst_doc_create_dt_list */
SELECT
   X.*, 
   NVL(X.MENINS1,0) + NVL(X.MENINS2,0) + NVL(X.MENINS3,0) as MENINS,
   (SELECT S.CODE_NAME FROM TBL_WORKING_MASTER S WHERE SUBSTR(S.CODE, 1, 1) = 'V' AND S.CODE = X.VENDOR_CODE) AS VENDOR_NAME, -- 거래처
   DECODE((SELECT S.CODE_NAME FROM TBL_WORKING_MASTER S WHERE SUBSTR(S.CODE, 1, 1) = 'U' AND S.CODE = X.UNIT_CODE),'톤','TON',(SELECT S.CODE_NAME FROM TBL_WORKING_MASTER S WHERE SUBSTR(S.CODE, 1, 1) = 'U' AND S.CODE = X.UNIT_CODE)) AS UNIT_NAME
FROM (
   SELECT
      A.BASE_YYYY AS BASE_YYYY, -- 년월
      A.VENDOR_CODE AS VENDOR_CODE, -- 거래처코드
      A.CONTRACT_CODE AS CONTRACT_CODE, -- 작업코드
      MAX(B.CONTRACT_NAME) AS CONTRACT_NAME, -- 작업명
      MAX(B.UNIT_CODE) AS UNIT_CODE, -- 단위코드
      CASE WHEN MAX(B.GUBUN_CODE) ='2' THEN NVL(SUM(A.MONTH_STANDARD_AMOUNT),0) ELSE 0 END MENINS1,  --당월협력업체(인력)
      CASE WHEN MAX(B.GUBUN_CODE) ='1' THEN NVL(SUM(A.QUANTITY_CHANGED), SUM(A.QUANTITY)) ELSE 0 END MENINS2,  --당월물량관리
      CASE WHEN MAX(B.GUBUN_CODE) ='3' THEN NVL(SUM(A.MONTH_STANDARD_AMOUNT),0) ELSE 0 END MENINS3,  --저장품
      NVL(SUM(A.UNIT_PRICE), 0) AS UNIT_PRICE, -- 단가
      NVL(SUM(A.REWARD_AMOUNT), 0) AS REWARD_AMOUNT, -- 보상
      NVL(SUM(A.ADDITIONAL_AMOUNT), 0) AS ADDITIONAL_AMOUNT, -- 추가
      NVL(SUM(A.PENALTY_AMOUNT), 0) AS PENALTY_AMOUNT, -- 패널티
      NVL(SUM(A.HOLIDAY_AMOUNT), 0) AS HOLIDAY_AMOUNT, -- 휴일근무
      NVL(SUM(A.SATURDAY_AMOUNT), 0) AS SATURDAY_AMOUNT, -- 토요근무
      NVL(SUM(A.EXTENSION_AMOUNT), 0) AS EXTENSION_AMOUNT, -- 연장근무
      NVL(SUM(A.NIGHT_AMOUNT), 0) AS NIGHT_AMOUNT, -- 야간근무
      NVL(SUM(A.PAY_AMOUNT), 0) AS PAY_AMOUNT, -- 금액
      SUM(PRE_PAY_AMOUNT) AS PRE_PAY_AMOUNT, -- 기지급액,
      NVL(SUM(A.PAY_AMOUNT), 0) - SUM(PRE_PAY_AMOUNT) AS RETROACTIVE_AMOUNT, -- 소급액
      MAX(B.GUBUN_CODE) AS GUBUN_CODE,
      CASE WHEN MAX(B.GUBUN_CODE) = '1' OR MAX(B.GUBUN_CODE) = '2' THEN '1'
           ELSE '0' END AS GUBUN_CODE2,
      MAX(B.COST_CODE) AS COST_CODE     
   FROM TBL_WORKING_MONTHLY_RPT_RT A
   INNER JOIN TBL_WORKING_SUBC B
      ON A.BASE_YYYY = B.BASE_YYYY
      AND A.VENDOR_CODE = B.VENDOR_CODE
      AND A.CONTRACT_CODE = B.CONTRACT_CODE
   INNER JOIN (
      SELECT
         C.BASE_YYYY,
         C.VENDOR_CODE,
         C.CONTRACT_CODE,
         NVL(SUM(C.PAY_AMOUNT), 0) AS PRE_PAY_AMOUNT
      FROM TBL_WORKING_MONTHLY_REPORT C
      INNER JOIN TBL_WORKING_SUBC S
         ON C.BASE_YYYY      = S.BASE_YYYY
         AND C.VENDOR_CODE   = S.VENDOR_CODE
         AND C.CONTRACT_CODE = S.CONTRACT_CODE
         AND C.CHECK_YYYYMM BETWEEN SUBSTR(S.RETROACT_START_DATE, 1, 6) AND SUBSTR(S.RETROACT_END_DATE, 1, 6)
      WHERE 1=1
      GROUP BY C.BASE_YYYY, C.VENDOR_CODE, C.CONTRACT_CODE
   ) C -- 소급기간의 도급월보 소계를 구함
      ON A.BASE_YYYY      = C.BASE_YYYY
      AND A.VENDOR_CODE   = C.VENDOR_CODE
      AND A.CONTRACT_CODE = C.CONTRACT_CODE
   WHERE 1=1
   AND A.VENDOR_CODE                = #{VENDOR_CODE}
   AND SUBSTR(A.CHECK_YYYYMM, 1, 4) = #{CHECK_YYYY}
   GROUP BY A.BASE_YYYY, A.VENDOR_CODE, A.CONTRACT_CODE
) X
WHERE 1=1
AND PAY_AMOUNT <![CDATA[>]]> 0	<!-- 20201207_KHJ 조용래 대리 요청으로 합계 0원인 계약들은 제외 -->
</select>

<update id="updateDocumentNumber">
/* oracle.yp_zwc_rst.updateDocumentNumber */
UPDATE TBL_WORKING_RETO_COST_COUNT
SET   SLIP_NUMBER  = #{doc_no},	/* 전표번호 저장 */
      BUDAT        = REPLACE(#{BUDAT}, '/', '')   /* 전표 전기일 저장 */
WHERE CHECK_YYYY   = REPLACE(#{CHECK_YYYYMM},'/','')
AND   VENDOR_CODE  = #{VENDOR_CODE}
AND   GUBUN_CODE   = #{GUBUN_CODE}
</update>

<select id="DocumentCheckList" resultType="HashMap">
/* oracle.yp_zwc_rst.DocumentCheckList */
SELECT 
	A.CHECK_YYYY,
	A.VENDOR_CODE,
	A.GUBUN_CODE,
	NVL(SLIP_NUMBER,'') as SLIP_NUMBER,
	A.BUDAT
FROM TBL_WORKING_RETO_COST_COUNT A
LEFT OUTER JOIN TBL_WORKING_MASTER B
ON A.VENDOR_CODE = B.CODE
WHERE 1=1
AND CHECK_YYYY = #{CHECK_YYYY}
AND GUBUN_CODE = #{GUBUN_CODE}
AND SLIP_NUMBER IS NOT NULL
</select>

<update id="DocumentNumberInit">
/* oracle.yp_zwc_rst.DocumentNumberInit */
UPDATE TBL_WORKING_RETO_COST_COUNT
SET   SLIP_NUMBER = NULL,
      BUDAT = NULL
WHERE SLIP_NUMBER = #{SLIP_NUMBER}
AND   BUDAT       = #{BUDAT}
</update>

</mapper>